# 数据结构
## 链表
- ### 单链表
  - 操作
    1. 追加节点
    2. 查找节点
    3. 插入节点
      - 虚拟头节点
    4. 删除节点
      - 虚拟头节点
- ### 双链表
- ### 循环链表
  - 循环单链表
  - 循环双链表
---

## 栈
  - 后进先出 LIFO (Last In First Out)
  - 操作
    1. 入栈 push
    2. 出栈 pop
---

## 队列
  - 先进先出 FIFO (First In First Out)
    - 操作
      1. 入队 push
      2. 出队 shift
  ### 双端队列
    - 操作
      1. push
      2. shift
      3. pop
      4. unshift
  ### 滑动窗口
---

## 散列表（Hash表）
  - 好的散列函数的基本要求：
    - 易于计算：它应该易于计算，并且不能成为算法本身。
    - 统一分布：它应该在哈希表中提供统一分布，不应导致群集。
    - 较少的冲突：当元素对映射到相同的哈希值时发生冲突。应该避免这些
  - 散列函数
    - 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。
    - 数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。
    - 平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。
    - 取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。
    - 除留取余法：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取素数或者直接用 n。
  - 冲突解决
    - 开放地址法（也叫开放寻址法）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。
    - 链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的，我们会在后面着重学习这种方式。
    - 再哈希法：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。
    - 建立一个公共溢出区：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。
  - 动态扩容