<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div>
    <canvas id="canvas" width="800" height="800"></canvas>
  </div>
  <div class="info"></div>

  <script src="./lib/cuon-matrix.js"></script>
  <script src="./lib/cuon-utils.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    const vSource = `
      attribute vec4 a_Position;
      attribute vec4 a_Color;
      attribute vec4 a_Normal; // 表面法向量
      uniform mat4 u_Matrix;
      uniform vec3 u_AmbientLight; // 环境光颜色
      uniform vec3 u_LightColor; // 光线颜色
      uniform vec3 u_LightDirection; // 归一化的世界坐标
      uniform mat4 u_NormalMatrix; // 法向量逆转置矩阵
      varying vec4 v_Color;

      void main(void) {
        gl_Position = u_Matrix * a_Position;
        vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal)); // 法向量归一化
        float nDotL = max(dot(u_LightDirection, normal), 0.0); // 光线方向和法向量的点积
        vec3 diffuse = u_LightColor * a_Color.rgb * nDotL; // 计算漫反射光的颜色
        vec3 ambient = u_AmbientLight * a_Color.rgb;
        v_Color = vec4(diffuse + ambient, a_Color.a);
      }
    `;
    const fSource = `
      precision mediump float;

      varying vec4 v_Color;

      void main() {
        gl_FragColor = v_Color;
      }
    `;
    
    let flag = initShaders(gl, vSource, fSource);
    if(!flag) throw(new Error());
    

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST); // 开启深度比较
    // gl.enable(gl.POLYGON_OFFSET_FILL); // 开启多边形深度值偏移
    // gl.polygonOffset(1.0, 1.0); // 计算偏移量的参数

    const data = new Float32Array([
      // 同色
      -1, 1, 1, 0, 0, 1,
      -1, -1, 1, 0, 0, 1,
      1, -1, 1, 0, 0, 1,
      1, 1, 1, 0, 0, 1,
      1, 1, -1, 0, 0, 1,
      1, -1, -1, 0, 0, 1,
      -1, -1, -1, 0, 0, 1,
      -1, 1, -1, 0, 0, 1,
    ]);
    const indices = new Uint8Array([
      0, 1, 2, 0, 3, 2, 
      0, 1, 6, 0, 7, 6,
      0, 3, 4, 0, 7, 4,
      5, 2, 3, 5, 4, 3,
      5, 2, 1, 5, 6, 1,
      5, 6, 7, 5, 4, 7,
    ]);
    const normalsData = new Float32Array([
      0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
      -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 
      0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 
      1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 
      0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 
      0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 
    ]);
    const n = indices.length;
    const FSIZE = data.BYTES_PER_ELEMENT;

    // 光线
    // 漫反射
    const u_LightColor = gl.getUniformLocation(gl.program, 'u_LightColor');
    const u_LightDirection = gl.getUniformLocation(gl.program, 'u_LightDirection');
    gl.uniform3f(u_LightColor, 1, 1, 1);
    const ldir = [0, 0, 1];
    const lightRotate = () => {
      const lightDirection = new Vector3(ldir).normalize(); // 光线方向
      gl.uniform3fv(u_LightDirection, lightDirection.elements);
    };
    lightRotate();

    // 环境光
    const u_AmbientLight = gl.getUniformLocation(gl.program, 'u_AmbientLight');
    gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2);
    
    const u_NormalMatrix = gl.getUniformLocation(gl.program, 'u_NormalMatrix'); // 逆转置矩阵

    
    // 顶点 buffer
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

    const a_Position = gl.getAttribLocation(gl.program, 'a_Position');
    const a_Color = gl.getAttribLocation(gl.program, 'a_Color');

    gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0);
    gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 6, FSIZE * 3);
    gl.enableVertexAttribArray(a_Position);
    gl.enableVertexAttribArray(a_Color);
    
    // 顶点索引 buffer
    const indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

    // 顶点法向量 buffer
    const normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normalsData, gl.STATIC_DRAW);
    const a_Normal = gl.getAttribLocation(gl.program, 'a_Normal');
    gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_Normal);

    const mat4 = new Matrix4();
    const u_Matrix = gl.getUniformLocation(gl.program, 'u_Matrix');
    
    /*
      <正投影矩阵 | 透视投影矩阵> * <视图矩阵> * <模型矩阵> * <顶点坐标>

      <漫反射光颜色> = <入射光颜色> * <表面基底色> * cosb
      <环境反射光颜色> = <入射光颜色> * <表面基底色>
      <表面的反射光颜色> = <漫反射光颜色> + <环境反射光颜色>
      cosb = <光线方向> · <法线方向>
    */

    let zAxis = 10;
    let xAxis = 0;
    let yAxis = 0;
    let rotateDeg = 0;
    const draw = () => {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const modelMatrix = new Matrix4();
      modelMatrix.rotate(rotateDeg, 0, 1, 0);

      mat4.setPerspective(30, canvas.width / canvas.height, 1, 100)
        .lookAt(xAxis, yAxis, zAxis, 0, 0, -10, 0, 1, 0).multiply(modelMatrix);
        
      gl.uniformMatrix4fv(u_Matrix, false, mat4.elements);
      modelMatrix.invert().transpose();
      gl.uniformMatrix4fv(u_NormalMatrix, false, modelMatrix.elements);

      gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
    };

    let prevTime = performance.now();
    const tick = (currentTime) => {
      const dt = currentTime - prevTime;
      prevTime = currentTime;
      rotateDeg = (rotateDeg + dt / 10) % 360;
      draw();

      return requestAnimationFrame(tick);
    };

    draw();
    // tick(prevTime);
    // lightRotate();

    // canvas.onmousemove = ev => {
    //   const scale = 10;
    //   const x = (ev.offsetX - 400) / -400 * scale;
    //   const y = (ev.offsetY - 400) / 400 * scale;
    //   xAxis = x;
    //   yAxis = y;
    //   draw();
    // };
     document.onkeydown = ev => {
      switch(ev.key) {
        // case 'w': ldir[1] += 0.1; break;
        // case 's': ldir[1] -= 0.1; break;
        // case 'a': ldir[0] -= 0.1; break;
        // case 'd': ldir[0] += 0.1; break;
        case 'ArrowUp': rotateDeg = (rotateDeg + 5) % 360; break;
        case 'ArrowDown': rotateDeg = (rotateDeg - 5) % 360; break;
        default: return;
      }
      // lightRotate();
      draw();
    };
  </script>
</body>
</html>